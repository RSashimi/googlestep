木構造を使えば O(log N)、ハッシュテーブルを使えばほぼ O(1) で検索・追加・削除を実現することができて、
これだけ見ればハッシュテーブルのほうが優れているように見える。ところが現実の大規模なデータベースでは、ハッシュテーブルではなく木構造が使われることが多い。
その理由を考えよ。

1. ハッシュテーブルは、データをバラバラな場所に置いている。(例:本のページに適当な番号を振って、どこにあるかわかるようにする感じ)
なので、特定のページ（データ）をピンポイントで探すのは得意だが、「100ページから200ページまでの本を探して」と言われると、全てのページをいちいち確認しないといけないと思う。
それに対して、木構造はデータをきちんと順番に並べて保管している。(図書館の本が背表紙の番号順に並んでいるのと同じ)
だから「100番から200番までのデータ」といったrange queryが可能である。実在するデータベースもほとんどこの形を使用していると思う。
MySQL, PostgreSQLのようなデータベースでは　SELECT * FROM hoge WHERE fuga >= 18 AND fuga <= 25; と言ってrange queryを投げることができる。
Elasticsearch のようなNoSQL型DB でも：
{
  "query": {
    "range": {
      "age": {
        "gte": 18,
        "lte": 25
      }
    }
  }
}
のようにrange query を投げることが可能である。


2. ハッシュテーブルはデータをどこに置くかは「ハッシュ値」という特殊な計算結果で決まるためデータの順番をあまり操作することができない、というか気にしていない。
  しかし、データベースでは「新しい順に並べたい」「名前のABC順に並べたい」といったように、データの順番が重要になることがよくあると思う。
  木構造は、データが常に順番に並んだ状態で管理されるのでデータを取り出すときにすでに順番通りになっているので、余計な手間がかからない。
  よく研究発表でdbの中身を見せるが、データの順番が混同していたら見る側も混乱すると思う。

3. collision の概念がない

4.B-treeなどはハードディスクから一度にたくさんのデータをまとめて読み込めるように工夫されてい流話をどこかで聞いたことがある。
　なのでハードディスクへのアクセス回数を減らして全体の処理を速くできる。ハッシュテーブルもディスクに保存することが可能だがとにかくデータが散らばっているので、効率的にまとめて読み込むのが難しい。




